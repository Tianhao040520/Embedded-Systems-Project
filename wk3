#include "mbed.h"                         
#include "C12832.h"
#include "QEI.h"
#include "pin_assignment.h"

// --- ENCODER CONFIGURATION ---
// PPR (Pulses Per Revolution) from datasheet. 
// Note: If using X4 encoding, your pulses per lap will be PPR * 4.
#define ENCODER_PPR 512

C12832 lcd(D11, D13, D12, D7, D10);



class Motor
{
private:
    PwmOut _pwm;        // Speed signal
    DigitalOut _dir;    // Direction signal
    float current_speed; // Speed value (0.0 to 1.0)
    bool dir_forward;   // Direction state

public:
    /**
     * @brief Constructor for the Motor class
     * @param pwm_pin Pin for PWM speed control
     * @param dir_pin Pin for Direction control
     */
    Motor(PinName pwm_pin, PinName dir_pin);


    /**
     * @brief Set the motor speed and direction
     * @param speed Float from -1.0 (Full Reverse) to 1.0 (Full Forward)
     */
    void set_speed(float speed); 

    /**
     * @brief Emergency stop - cuts power immediately
     */
    void stop();

    // Getters for telemetry
    float get_speed() const { return current_speed; }

};

Motor::Motor(PinName pwm_pin, PinName dir_pin) : _pwm(pwm_pin), _dir(dir_pin) {
    // 20kHz is standard to avoid audible noise
    _pwm.period_us(50); 
    stop();
}

void Motor::set_speed(float speed) {
    // 1. Constrain speed to valid range [-1.0, 1.0]
    if (speed > 1.0f) speed = 1.0f;
    if (speed < -1.0f) speed = -1.0f;

    // 2. Determine Direction
    if (speed >= 0) {
        _dir = 1; // Forward logic
        current_speed = speed;
    } else {
        _dir = 0; // Reverse logic
        current_speed = -speed; // PWM duty cycle must be positive
    }

    // 3. Update Hardware
    _pwm.write(current_speed);
}

void Motor::stop() {
    _pwm.write(0.0f);
    current_speed = 0.0f;
}


class MotorDriverBoard
{
private:
    DigitalOut board_enable;            // pin  for enabling the board
    bool enable_state;                  // state of the enable pin

    int VoltageReading, CurrentReading; // gets the value of voltage and current as integers per unit value referred to in the ds2781.cpp in more detail
    float Voltage, Current;             // actual value of the voltage and current

public:
    

};



// --- 2. HARDWARE OBJECTS ---
DigitalOut driver_board_en(DRIVER_ENABLE_PIN);

Motor left_motor(MOTORL_PWM_PIN, MOTORL_DIRECTION_PIN);
Motor right_motor(MOTORR_PWM_PIN, MOTORR_DIRECTION_PIN);

// QEI(PinName channelA, PinName channelB, PinName index, int pulsesPerRev, Encoding encoding)
QEI enc_left(MOTORL_CHA_PIN, MOTORL_CHB_PIN, NC, ENCODER_PPR, QEI::X4_ENCODING);
QEI enc_right(MOTORR_CHA_PIN, MOTORR_CHB_PIN, NC, ENCODER_PPR, QEI::X4_ENCODING);

// --- DIMENSIONAL ANALYSIS HELPER ---
float pulses_to_distance(int pulses) {
    float wheel_diameter = 0.082; // 0.082m
    float gear_ratio = 15.0f;       // 15:1 gearbox CHECK AGAIN
    float pi = 3.14159f;
    
    // Distance = (Total Ticks / (PPR * Encoding * GearRatio)) * Circumference
    // For X4 encoding, we divide by (PPR * 4)
    return ((float)pulses / (ENCODER_PPR * 4 * gear_ratio)) * (pi * wheel_diameter);
}

void move_straight(float target_meters) {
    enc_left.reset();
    enc_right.reset();
    
    left_motor.set_speed(0.4f);
    right_motor.set_speed(0.4f);
    
    // Loop until the average distance reaches target
    while(pulses_to_distance(enc_left.getPulses()) < target_meters) {
        // You can add minor corrections here if it veers!
        wait(5);
    }
    
    left_motor.stop();
    right_motor.stop();
}

Serial pc(USBTX, USBRX, 115200);            // set up serial comm with pc

int main(){

    // Initial Safety State
    driver_board_en = 0; // Board disabled
    left_motor.stop();
    right_motor.stop();
    
    while(1){
        
        pc.printf("test");
        driver_board_en = 1; // Enable the H-Bridge

        int left_ticks = enc_left.getPulses();
        int right_ticks = enc_right.getPulses();
        
        float dist_m = pulses_to_distance(left_ticks);
            
        left_motor.set_speed(0.6f);  // Forward 
        right_motor.set_speed(0.6f); 
        wait(5);
        
        left_motor.stop();
        right_motor.stop();
        wait(2);
            
        left_motor.set_speed(-0.6f);  // Reverse 
        right_motor.set_speed(-0.6f); 
        wait(5);

        left_motor.stop();
        right_motor.stop();
        wait(2);
    }


}

